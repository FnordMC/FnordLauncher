name: Build

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - "develop"
      - "release-*"
    paths:
      # File types
      - "**.cpp"
      - "**.h"
      - "**.java"
      - "**.ui"

      # Directories
      - "buildconfig/**"
      - "cmake/**"
      - "launcher/**"
      - "libraries/**"
      - "program_info/**"
      - "tests/**"

      # Files
      - "CMakeLists.txt"
      - "COPYING.md"

      # Workflows
      - ".github/workflows/build.yml"
      - ".github/actions/package/**"
      - ".github/actions/setup-dependencies/**"
  pull_request:
    paths:
      # File types
      - "**.cpp"
      - "**.h"
      - "**.java"
      - "**.ui"

      # Directories
      - "buildconfig/**"
      - "cmake/**"
      - "launcher/**"
      - "libraries/**"
      - "program_info/**"
      - "tests/**"

      # Files
      - "CMakeLists.txt"
      - "COPYING.md"

      # Workflows
      - ".github/workflows/build.yml"
      - ".github/actions/package/**"
      - ".github/actions/setup-dependencies/**"
  workflow_call:
    inputs:
      build-type:
        description: Type of build (Debug or Release)
        type: string
        default: Debug
      environment:
        description: Deployment environment to run under
        type: string
  workflow_dispatch:
    inputs:
      build-type:
        description: Type of build (Debug or Release)
        type: string
        default: Debug

jobs:
  build:
    name: Build (${{ matrix.artifact-name }})

    environment: ${{ inputs.environment || '' }}

    permissions:
      # Required for Azure Trusted Signing
      id-token: write
      # Required for vcpkg binary cache
      packages: write

    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-24.04
            artifact-name: Linux
            cmake-preset: linux
            qt-version: 6.10.1

          - os: ubuntu-24.04-arm
            artifact-name: Linux-aarch64
            cmake-preset: linux
            qt-version: 6.10.1

          - os: windows-2022
            artifact-name: Windows-MinGW-w64
            cmake-preset: windows_mingw
            msystem: CLANG64
            vcvars-arch: amd64_x86

          - os: windows-11-arm
            artifact-name: Windows-MinGW-arm64
            cmake-preset: windows_mingw
            msystem: CLANGARM64
            vcvars-arch: arm64

          - os: windows-2022
            artifact-name: Windows-MSVC
            cmake-preset: windows_msvc
            # TODO(@getchoo): This is the default in setup-dependencies/windows. Why isn't it working?!?!
            vcvars-arch: amd64
            qt-version: 6.10.1

          - os: windows-11-arm
            artifact-name: Windows-MSVC-arm64
            cmake-preset: windows_msvc
            vcvars-arch: arm64
            qt-version: 6.10.1

          - os: macos-26
            artifact-name: macOS
            cmake-preset: macos_universal
            macosx-deployment-target: 12.0
            qt-version: 6.9.3

    runs-on: ${{ matrix.os }}

    defaults:
      run:
        shell: ${{ matrix.msystem != '' && 'msys2 {0}' || 'bash' }}

    env:
      ARTIFACT_NAME: ${{ matrix.artifact-name }}-Qt6
      BUILD_PLATFORM: official
      BUILD_TYPE: ${{ inputs.build-type || 'Debug' }}
      CMAKE_PRESET: ${{ matrix.cmake-preset }}

      MACOSX_DEPLOYMENT_TARGET: ${{ matrix.macosx-deployment-target }}

    steps:
      ##
      # SETUP
      ##

      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: true

      - name: Setup dependencies
        id: setup-dependencies
        uses: ./.github/actions/setup-dependencies
        with:
          build-type: ${{ env.BUILD_TYPE }}
          artifact-name: ${{ matrix.artifact-name }}
          msystem: ${{ matrix.msystem }}
          vcvars-arch: ${{ matrix.vcvars-arch }}
          qt-version: ${{ matrix.qt-version }}

      ##
      # BUILD
      ##

      - name: Configure project
        run: |
          cmake --preset "$CMAKE_PRESET"

      - name: Run build
        run: |
          cmake --build --preset "$CMAKE_PRESET" --config "$BUILD_TYPE"

      - name: Run tests
        run: |
          ctest --preset "$CMAKE_PRESET" --build-config "$BUILD_TYPE"

      ##
      # PACKAGE
      ##

      - name: Get short version
        id: short-version
        shell: bash
        run: |
          echo "version=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"

      - name: Package (Linux)
        if: ${{ runner.os == 'Linux' }}
        uses: ./.github/actions/package/linux
        with:
          version: ${{ steps.short-version.outputs.version }}
          build-type: ${{ steps.setup-dependencies.outputs.build-type }}
          artifact-name: ${{ matrix.artifact-name }}
          qt-version: ${{ steps.setup-dependencies.outputs.qt-version }}

          gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
          gpg-private-key-id: ${{ secrets.GPG_PRIVATE_KEY_ID }}

      - name: Package (macOS)
        if: ${{ runner.os == 'macOS' }}
        uses: ./.github/actions/package/macos
        with:
          version: ${{ steps.short-version.outputs.version }}
          build-type: ${{ steps.setup-dependencies.outputs.build-type }}
          artifact-name: ${{ matrix.artifact-name }}

<<<<<<< HEAD
          cd ${{ env.INSTALL_DIR }}
          chmod +x "FnordLauncher.app/Contents/MacOS/fnordlauncher"

          if [ -n '${{ secrets.APPLE_CODESIGN_ID }}' ]; then
            APPLE_CODESIGN_ID='${{ secrets.APPLE_CODESIGN_ID }}'
          else
            APPLE_CODESIGN_ID='-'
          fi

          sudo codesign --sign "$APPLE_CODESIGN_ID" --deep --force --entitlements "../program_info/App.entitlements" --options runtime "FnordLauncher.app/Contents/MacOS/fnordlauncher"
          mv "FnordLauncher.app" "Fnord Launcher.app"

      - name: Notarize (macOS)
        if: runner.os == 'macOS'
        run: |
          cd ${{ env.INSTALL_DIR }}

          if [ -n '${{ secrets.APPLE_NOTARIZE_PASSWORD }}' ]; then
            ditto -c -k --sequesterRsrc --keepParent "Fnord Launcher.app" ../FnordLauncher.zip
            xcrun notarytool submit ../FnordLauncher.zip \
              --wait --progress \
              --apple-id '${{ secrets.APPLE_NOTARIZE_APPLE_ID }}' \
              --team-id '${{ secrets.APPLE_NOTARIZE_TEAM_ID }}' \
              --password '${{ secrets.APPLE_NOTARIZE_PASSWORD }}'

            xcrun stapler staple "Fnord Launcher.app"
          else
            echo ":warning: Skipping notarization as credentials are not present." >> $GITHUB_STEP_SUMMARY
          fi
          ditto -c -k --sequesterRsrc --keepParent "Fnord Launcher.app" ../FnordLauncher.zip

      - name: Make Sparkle signature (macOS)
        if: matrix.name == 'macOS'
        run: |
          if [ '${{ secrets.SPARKLE_ED25519_KEY }}' != '' ]; then
            echo '${{ secrets.SPARKLE_ED25519_KEY }}' > ed25519-priv.pem
            signature=$(/opt/homebrew/opt/openssl@3/bin/openssl pkeyutl -sign -rawin -in ${{ github.workspace }}/FnordLauncher.zip -inkey ed25519-priv.pem | openssl base64 | tr -d \\n)
            rm ed25519-priv.pem
            cat >> $GITHUB_STEP_SUMMARY << EOF
          ### Artifact Information :information_source:
          - :memo: Sparkle Signature (ed25519): \`$signature\`
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY << EOF
          ### Artifact Information :information_source:
          - :warning: Sparkle Signature (ed25519): No private key available (likely a pull request or fork)
          EOF
          fi

      - name: Package (Windows MinGW-w64)
        if: runner.os == 'Windows' && matrix.msystem != ''
        shell: msys2 {0}
        run: |
          cmake --install ${{ env.BUILD_DIR }}
          touch ${{ env.INSTALL_DIR }}/manifest.txt
          for l in $(find ${{ env.INSTALL_DIR }} -type f); do l=$(cygpath -u $l); l=${l#$(pwd)/}; l=${l#${{ env.INSTALL_DIR }}/}; l=${l#./}; echo $l; done >> ${{ env.INSTALL_DIR }}/manifest.txt

      - name: Package (Windows MSVC)
        if: runner.os == 'Windows' && matrix.msystem == ''
        run: |
          cmake --install ${{ env.BUILD_DIR }} --config ${{ inputs.build_type }}

          cd ${{ github.workspace }}

          Get-ChildItem ${{ env.INSTALL_DIR }} -Recurse | ForEach FullName | Resolve-Path -Relative | %{ $_.TrimStart('.\') } | %{ $_.TrimStart('${{ env.INSTALL_DIR }}') } | %{ $_.TrimStart('\') } | Out-File -FilePath ${{ env.INSTALL_DIR }}/manifest.txt

      - name: Fetch codesign certificate (Windows)
        if: runner.os == 'Windows'
        shell: bash # yes, we are not using MSYS2 or PowerShell here
        run: |
          echo '${{ secrets.WINDOWS_CODESIGN_CERT }}' | base64 --decode > codesign.pfx

      - name: Sign executable (Windows)
        if: runner.os == 'Windows'
        run: |
          if (Get-Content ./codesign.pfx){
            cd ${{ env.INSTALL_DIR }}
            # We ship the exact same executable for portable and non-portable editions, so signing just once is fine
            SignTool sign /fd sha256 /td sha256 /f ../codesign.pfx /p '${{ secrets.WINDOWS_CODESIGN_PASSWORD }}' /tr http://timestamp.digicert.com fnordlauncher.exe fnordlauncher_updater.exe fnordlauncher_filelink.exe 
          } else {
            ":warning: Skipped code signing for Windows, as certificate was not present." >> $env:GITHUB_STEP_SUMMARY
          }

      - name: Package (Windows MinGW-w64, portable)
        if: runner.os == 'Windows' && matrix.msystem != ''
        shell: msys2 {0}
        run: |
          cp -r ${{ env.INSTALL_DIR }} ${{ env.INSTALL_PORTABLE_DIR }}  # cmake install on Windows is slow, let's just copy instead
          cmake --install ${{ env.BUILD_DIR }} --prefix ${{ env.INSTALL_PORTABLE_DIR }} --component portable
          for l in $(find ${{ env.INSTALL_PORTABLE_DIR }} -type f); do l=$(cygpath -u $l); l=${l#$(pwd)/}; l=${l#${{ env.INSTALL_PORTABLE_DIR }}/}; l=${l#./}; echo $l; done >> ${{ env.INSTALL_PORTABLE_DIR }}/manifest.txt

      - name: Package (Windows MSVC, portable)
        if: runner.os == 'Windows' && matrix.msystem == ''
        run: |
          cp -r ${{ env.INSTALL_DIR }} ${{ env.INSTALL_PORTABLE_DIR }}  # cmake install on Windows is slow, let's just copy instead
          cmake --install ${{ env.BUILD_DIR }} --prefix ${{ env.INSTALL_PORTABLE_DIR }} --component portable

          Get-ChildItem ${{ env.INSTALL_PORTABLE_DIR }} -Recurse | ForEach FullName | Resolve-Path -Relative | %{ $_.TrimStart('.\') } | %{ $_.TrimStart('${{ env.INSTALL_PORTABLE_DIR }}') } | %{ $_.TrimStart('\') } | Out-File -FilePath ${{ env.INSTALL_DIR }}/manifest.txt

      - name: Package (Windows, installer)
        if: runner.os == 'Windows'
        run: |
          if ('${{ matrix.nscurl_tag }}') {
            New-Item -Name NSISPlugins -ItemType Directory
            Invoke-Webrequest https://github.com/negrutiu/nsis-nscurl/releases/download/${{ matrix.nscurl_tag }}/NScurl.zip -OutFile NSISPlugins\NScurl.zip
            $nscurl_hash = Get-FileHash NSISPlugins\NScurl.zip -Algorithm Sha256 | Select-Object -ExpandProperty Hash
            if ( $nscurl_hash -ne "${{ matrix.nscurl_sha256 }}") {
              echo "::error:: NSCurl.zip sha256 mismatch"
              exit 1
            }
            Expand-Archive -Path NSISPlugins\NScurl.zip -DestinationPath NSISPlugins\NScurl
          }
          cd ${{ env.INSTALL_DIR }}
          makensis -NOCD "${{ github.workspace }}/${{ env.BUILD_DIR }}/program_info/win_install.nsi"

      - name: Sign installer (Windows)
        if: runner.os == 'Windows'
        run: |
          if (Get-Content ./codesign.pfx){
            SignTool sign /fd sha256 /td sha256 /f codesign.pfx /p '${{ secrets.WINDOWS_CODESIGN_PASSWORD }}' /tr http://timestamp.digicert.com fnordLauncher-Setup.exe
          } else {
            ":warning: Skipped code signing for Windows, as certificate was not present." >> $env:GITHUB_STEP_SUMMARY
          }

      - name: Package AppImage (Linux)
        if: runner.os == 'Linux' && matrix.qt_ver != 5
        shell: bash
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          cmake --install ${{ env.BUILD_DIR }} --prefix ${{ env.INSTALL_APPIMAGE_DIR }}/usr

          mv ${{ env.INSTALL_APPIMAGE_DIR }}/usr/share/metainfo/gg.arson.FnordLauncher.metainfo.xml ${{ env.INSTALL_APPIMAGE_DIR }}/usr/share/metainfo/org.fnordlauncher.FnordLauncher.appdata.xml
          export "NO_APPSTREAM=1" # we have to skip appstream checking because appstream on ubuntu 20.04 is outdated

          export OUTPUT="FnordLauncher-Linux-x86_64.AppImage"

          chmod +x linuxdeploy-*.AppImage

          mkdir -p ${{ env.INSTALL_APPIMAGE_DIR }}/usr/lib
          mkdir -p ${{ env.INSTALL_APPIMAGE_DIR }}/usr/plugins/iconengines

          cp -r ${{ runner.workspace }}/Qt/${{ matrix.qt_version }}/gcc_64/plugins/iconengines/* ${{ env.INSTALL_APPIMAGE_DIR }}/usr/plugins/iconengines

          cp /usr/lib/x86_64-linux-gnu/libcrypto.so.* ${{ env.INSTALL_APPIMAGE_DIR }}/usr/lib/
          cp /usr/lib/x86_64-linux-gnu/libssl.so.* ${{ env.INSTALL_APPIMAGE_DIR }}/usr/lib/
          cp /usr/lib/x86_64-linux-gnu/libOpenGL.so.0* ${{ env.INSTALL_APPIMAGE_DIR }}/usr/lib/

          LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${{ env.INSTALL_APPIMAGE_DIR }}/usr/lib"
          export LD_LIBRARY_PATH

          chmod +x AppImageUpdate-x86_64.AppImage
          cp AppImageUpdate-x86_64.AppImage ${{ env.INSTALL_APPIMAGE_DIR }}/usr/bin

          export UPDATE_INFORMATION="gh-releases-zsync|${{ github.repository_owner }}|${{ github.event.repository.name }}|latest|FnordLauncher-Linux-x86_64.AppImage.zsync" 

          if [ '${{ secrets.GPG_PRIVATE_KEY_ID }}' != '' ]; then
            export SIGN=1
            export SIGN_KEY=${{ secrets.GPG_PRIVATE_KEY_ID }}
            mkdir -p ~/.gnupg/
            echo "$GPG_PRIVATE_KEY" > ~/.gnupg/private.key
            gpg --import ~/.gnupg/private.key
          else
            echo ":warning: Skipped code signing for Linux AppImage, as gpg key was not present." >> $GITHUB_STEP_SUMMARY
          fi

          ./linuxdeploy-x86_64.AppImage --appdir ${{ env.INSTALL_APPIMAGE_DIR }} --output appimage --plugin qt -i ${{ env.INSTALL_APPIMAGE_DIR }}/usr/share/icons/hicolor/scalable/apps/gg.arson.FnordLauncher.svg

          mv "FnordLauncher-Linux-x86_64.AppImage" "FnordLauncher-Linux-${{ env.VERSION }}-${{ inputs.build_type }}-x86_64.AppImage"

      - name: Package (Linux, portable)
        if: runner.os == 'Linux'
        run: |
          cmake -S . -B ${{ env.BUILD_DIR }} -DCMAKE_INSTALL_PREFIX=${{ env.INSTALL_PORTABLE_DIR }} -DCMAKE_BUILD_TYPE=${{ inputs.build_type }} -DENABLE_LTO=ON -DLauncher_BUILD_PLATFORM=official -DCMAKE_C_COMPILER_LAUNCHER=${{ env.CCACHE_VAR }} -DCMAKE_CXX_COMPILER_LAUNCHER=${{ env.CCACHE_VAR }} -DLauncher_QT_VERSION_MAJOR=${{ matrix.qt_ver }} -DLauncher_BUILD_ARTIFACT=Linux-Qt${{ matrix.qt_ver }} -DINSTALL_BUNDLE=full -G Ninja
          cmake --install ${{ env.BUILD_DIR }}
          cmake --install ${{ env.BUILD_DIR }} --component portable

          mkdir  ${{ env.INSTALL_PORTABLE_DIR }}/lib
          cp /lib/x86_64-linux-gnu/libbz2.so.1.0 ${{ env.INSTALL_PORTABLE_DIR }}/lib
          cp /usr/lib/x86_64-linux-gnu/libgobject-2.0.so.0 ${{ env.INSTALL_PORTABLE_DIR }}/lib
          cp /usr/lib/x86_64-linux-gnu/libcrypto.so.* ${{ env.INSTALL_PORTABLE_DIR }}/lib
          cp /usr/lib/x86_64-linux-gnu/libssl.so.* ${{ env.INSTALL_PORTABLE_DIR }}/lib
          cp /usr/lib/x86_64-linux-gnu/libffi.so.*.* ${{ env.INSTALL_PORTABLE_DIR }}/lib
          mv ${{ env.INSTALL_PORTABLE_DIR }}/bin/*.so* ${{ env.INSTALL_PORTABLE_DIR }}/lib

          for l in $(find ${{ env.INSTALL_PORTABLE_DIR }} -type f); do l=${l#$(pwd)/}; l=${l#${{ env.INSTALL_PORTABLE_DIR }}/}; l=${l#./}; echo $l; done > ${{ env.INSTALL_PORTABLE_DIR }}/manifest.txt
          cd ${{ env.INSTALL_PORTABLE_DIR }}
          tar -czf ../FnordLauncher-portable.tar.gz *

      ##
      # UPLOAD BUILDS
      ##

      - name: Upload binary tarball (macOS)
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ matrix.name }}-${{ env.VERSION }}-${{ inputs.build_type }}
          path: FnordLauncher.zip

      - name: Upload binary zip (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ matrix.name }}-${{ env.VERSION }}-${{ inputs.build_type }}
          path: ${{ env.INSTALL_DIR }}/**

      - name: Upload binary zip (Windows, portable)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ matrix.name }}-Portable-${{ env.VERSION }}-${{ inputs.build_type }}
          path: ${{ env.INSTALL_PORTABLE_DIR }}/**

      - name: Upload installer (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ matrix.name }}-Setup-${{ env.VERSION }}-${{ inputs.build_type }}
          path: FnordLauncher-Setup.exe

      - name: Upload binary tarball (Linux, portable, Qt 5)
        if: runner.os == 'Linux' && matrix.qt_ver != 6
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ runner.os }}-Qt5-Portable-${{ env.VERSION }}-${{ inputs.build_type }}
          path: FnordLauncher-portable.tar.gz

      - name: Upload binary tarball (Linux, portable, Qt 6)
        if: runner.os == 'Linux' && matrix.qt_ver != 5
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ runner.os }}-Qt6-Portable-${{ env.VERSION }}-${{ inputs.build_type }}
          path: FnordLauncher-portable.tar.gz

      - name: Upload AppImage (Linux)
        if: runner.os == 'Linux' && matrix.qt_ver != 5
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ runner.os }}-${{ env.VERSION }}-${{ inputs.build_type }}-x86_64.AppImage
          path: FnordLauncher-${{ runner.os }}-${{ env.VERSION }}-${{ inputs.build_type }}-x86_64.AppImage

      - name: Upload AppImage Zsync (Linux)
        if: runner.os == 'Linux' && matrix.qt_ver != 5
        uses: actions/upload-artifact@v4
        with:
          name: FnordLauncher-${{ runner.os }}-${{ env.VERSION }}-${{ inputs.build_type }}-x86_64.AppImage.zsync
          path: FnordLauncher-Linux-x86_64.AppImage.zsync

      - name: ccache stats (Windows MinGW-w64)
        if: runner.os == 'Windows' && matrix.msystem != ''
        shell: msys2 {0}
        run: |
          ccache -s
=======
          apple-codesign-cert: ${{ secrets.APPLE_CODESIGN_CERT }}
          apple-codesign-password: ${{ secrets.APPLE_CODESIGN_PASSWORD }}
          apple-codesign-id: ${{ secrets.APPLE_CODESIGN_ID }}
          apple-notarize-apple-id: ${{ secrets.APPLE_NOTARIZE_APPLE_ID }}
          apple-notarize-team-id: ${{ secrets.APPLE_NOTARIZE_TEAM_ID }}
          apple-notarize-password: ${{ secrets.APPLE_NOTARIZE_PASSWORD }}
          sparkle-ed25519-key: ${{ secrets.SPARKLE_ED25519_KEY }}

      - name: Package (Windows)
        if: ${{ runner.os == 'Windows' }}
        uses: ./.github/actions/package/windows
        env:
          CI_HAS_ACCESS_TO_AZURE: ${{ vars.CI_HAS_ACCESS_TO_AZURE || '' }}
        with:
          version: ${{ steps.short-version.outputs.version }}
          build-type: ${{ steps.setup-dependencies.outputs.build-type }}
          artifact-name: ${{ matrix.artifact-name }}
          msystem: ${{ matrix.msystem }}

          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
>>>>>>> upstream/HEAD
